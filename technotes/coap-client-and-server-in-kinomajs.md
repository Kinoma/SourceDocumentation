Use of network connections by IoT devices is increasingly common. Even a tiny device in the kitchen might connect to the Internet. HTTP is popular protocol for these connections now. Even though HTTP works reasonably well for many IoT devices, there are many problems we have to solve with it, such as efficiency and speed. These factor impact the device battery life which is an important concern on IoT devices.

CoAP, Constrained Application Protocol, is very young protocol. It is designed to be used for constrained devices commonly found in IoT. It is very lightweight, fast and can be reliable enough for IoT uses. For developers familiar with TCP/IP, CoAP uses UDP for its transport layer, not TCP. UDP is packet based protocol, whereas TCP is stream based. Data must fit in a single packet whose size varies from about 1K for regular PC to less than 100 bytes for constraint devices. This constraints UDP suitable for small amounts data as sensor data.
* * * 
## Problem of TCP and HTTP
TCP is a great transport layer for networking. It is reliable. That's why so many protocols, including HTTP, build on TCP. But to achieve that, TCP does a lot of works behind the scenes.

TCP requires a connection to the destination before it starts communicating. It uses three packets to establish a connection. Also the TCP packet header is more than 12 bytes larger than UDP's. In some situation, these small costs become significant.

On top of that, HTTP adds its own header overhead. According to the report of Google SPDY, average HTTP request has 700 to 800 bytes of headers today. That number is huge. Of course most of them are used as its cookie which is not commonly required in IoT devices, but if the cookie is domain-wide and request is generated by the browser’s AJAX, those cookie will be automatically attached to the request.

Also HTTP headers are composed by just text, the cost of parsing such human-readable text cannot be ignored for small devices. Further, many HTTP headers aren’t required for communication and so are ignored after paying the cost of parsing.
* * * 
## UDP based reliable protocol
UDP is a simple transport layer. It is fast and lightweight. UDP is a connectionless protocol which simply sends a data packet to the destination without the need of connection handshake. Data can be sent at any time, without having to establish a connection first. These are the reasons why CoAP chose UDP for its transport layer.

However, UDP is far less reliable than TCP. Each packet may arrive once, more than once, or never. The order of packet delivery is undefined; the first packet may arrive later than second one. The sender has no way to know if the recipient received the packet.

Because CoAP uses UDP for network transport, delivery of packets is unreliable by default. When sending a packet, the application has the option to make delivery of the packet reliable. Reliable transmission is achieved by marking individual messages with the confirmable flag. When an endpoint receives a confirmable message, it responds with the Acknowledgement message to let the sender know the message arrived. Each message has its own ID number, so an endpoint can distinguish messages. An endpoint will automatically retransmit a confirmable messages if an Acknowledgement message is not received in the timeout interval.

Like HTTP, a CoAP message has also headers, Unlike HTTP, the CoAP headers are a compact binary format representing a minimum subset of HTTP’s large header specification. As binary data it is easy to parse to read required headers.
* * * 
## CoAP and HTTP similarities
From programmer's view, CoAP and HTTP are very similar. Today HTTP is the basis of Web API, which is heavily used in REST style communication.

HTTP uses a URI to identify the target destination and resource. CoAP does the same. HTTP uses requests and responses style communication which means there are a client who send a request and a server who get the request and send back a response to the client. CoAP’s communication style is the same. There is a client and a server. CoAP’s message also has content-type to specify what kind of format is used to describe its content.

With URI, we can use GET / POST / PUT / DELETE method with CoAP communication just like HTTP.
* * * 
## KinomaJS implementation of CoAP Client and Server
A CoAP client and server are included in Kinoma Create and Kinoma Studio starting with Kinoma Software 7.0.4,. The client is very simple to use. Here’s an example:

	var client = new CoAP.Client();
	var request = client.createRequest('coap://iot.eclipse.org/query?hello=world');
	request.onResponse = function(response) {
    	trace(response.payload + "\n");
  	};
  	client.send(request);
The server is equally simple. Configure the newly created server by binding the actual function to the path (in this case, ‘/hello’).

	var server = new CoAP.Server();
	server.bind("/hello", function(session) {
		var response = session.createResponse();
		response.payload = "Hello world";
	});
	server.start();
If the IP address of the Kinoma Create running the above code is 10.85.20.144, the URL of above function on this CoAP server is **coap://10.85.20.144/hello**.
* * * 
## Client side: Configuring a request
Make a request confirmable by setting **confirmable** property to true.

	request.confirmable = true;
The method is set by the **method** property.

	request.method = 'GET';
A request can have data, called payload. There are two ways to set request’s payload. Setting **payload** property to set plain text data.

	request.payload = "Hello world";
In this case, the content format is automatically text. Alternatively call the **setPayload()** method to set the content format.

	var data = { result: -1, status: "OK" };
	request.setPayload(JSON.stringify(data), 'json');
The content format can be set to the following values in CoAP:

*	text/plain; charset=utf-8
*	text/plain
*	text
*	application/xml
*	xml
*	application/octet-stream
*	octet-stream
*	application/json
*	json

The KinomaJS CoAP implementation provides aliases for the formats for convenience. For example, the text format is formally “text/plain; charset=utf-8”, but you can specify “text/plain” or just “text”. Same with “application/xml” as “xml”, “application/octet-stream” as “octet-stream” or “application/json” as “json”.
* * * 
## Client side: Handling a response event
To receive the response from a server, the request object can have event handlers as properties.

The **onResponse** event is called to process response from the server.

	request.onResponse = function(response) {
    var data = response.payload;
    // do some task with the response
	};
The response object has payload property for the response contents.

	var data = response.payload;
There is contentFormat property also, so it is easy to handle differently depending by the format.

	var format = response.contentFormat.split(';')[0];
	if (format == 'application/json') {
		data = JSON.parse(response.payload);
	} else if (format == 'text/plain') {
	data = response.payload;
	} else {
		throw "unknow foramt";
	}
To be notified when a confirmable request sent by the client has been acknowledged by the receiver, set the **onAck** property.

	request.onAck = function() {
		// We know the server get my request. Yeah!
	};
* * * 
## Server side: Handling a request and sending a response
On server side, request information is available from the session object. The following properties are available. All are read only.

	session.method; // GET / POST / PUT / DELETE
	session.confirmable; // true or false
	session.messageId; // e.g. 1234
	session.payload; // e.g. "Hello world"
	session.contentFormat; // text/plain; charset=utf-8
	session.uri; // coap://10.85.20.144:5683/hello?foo=bar&a=123
	session.host; // 10.85.20.144
	session.port; // 5683
	session.path; // /hello
	session.query; // foo=bar&a=123 
A session creates a response using the **createResponse()** method.

	var response = session.createResponse();
Build the response by setting its payload just like the request.

	response.payload = 'Sayonara';
In addition to the payload, set status code of the response using **setCode()**. The next sction provides details on the response code.

	response.setCode(2, 5); // default success response code
	response.setCode(4, 3); // Forbidden
Finally when the response is ready to be sent, call **send** method to send it back.

	session.send(response);
Please don’t forget to do this. No response is sent automatically.
* * * 
##Response code
The previous section shows how to set the response code of the response. The response code is similar to an HTTP’s status code, with small differences. The most noticeable difference is that it is not one digit, but two, a pair of **class** and **detail**.

Classes describe that the response is success or failure.

*	2: Success
*	4: Client Error
*	5: Server Error

Details defer from class to class. These are some examples.

*	2.01: Created
*	2.05: Content
*	4.01: Unauthorized
*	4.05: Method Not Allowed
*	4.13: Request Entity Too Large

Some are very familiar. Some are CoAP specific ones. Please check the [official document](https://tools.ietf.org/html/rfc7252#section-5.9) for further information.
* * * 
##Observe - Multiple response from server
**Observe** is very important standard extension for CoAP. It provides publish and subscribe style communication. With the Observe extension, a CoAP client can send a registration request and once it is accepted by the server, the client will receive multiple notification responses, based on the semantics of the server endpoint. It can be once every five minutes, immediately after the value changes, or as fast as possible like a continuous realtime notification. Its contents can be anything. The basic structure of the notification is similar to a regular response.
![](http://kinoma.com/develop/documentation/technotes/images/coap-client-and-server-in-kinomaJS/observe-multiple-response-from-server.jpg)

Instantiating the observe registration request is simple. Mark the **observe** property with true.

	request.observe = true;
To handle observe request requires two phases: (1) when the server receives the registration request and (2) when it wants to send a notification to the observer clients.

An observe request has true in its **observe** property, so start by checking the property. Call **acceptObserve()** method to let client know observe request is successfully accepted. If acceptObserve is not called the request handler, the server considers the observe request denied.

	if (session.observe) {
		// session registration
    	session.acceptObserve();
    	sessions.push(session.id);
 	}
  	var response = session.createResponse();
  	response.setCode(2, 5);
  	session.send(response);
  	
In this example, the global variable **sessions** is used to remember observer’s session ID. The session ID is required to send a notification response back to the client.

More than one client can observe same resource of the server. That’s why the **sessions** variable is array.

After the registration phase completes, send back a notification response whenever appropriate, such as when the user tap the button, a sensor detects a value change, or at specific time intervals.

	sessions.forEach(function(id) {
		var session = server.getSession(id);
		if (session) {
		// send a response as usual with the session
		} else {
			// remove that id from sessions
		}
	});
As described earlier, there can be more than one observer, so loop with session ID in the **sessions** array. From **server** object, session can be retrieved by **getSession** method. Check that the session is null or not before using it, because it is possible that the session is invalidated because of the communication error or cancelled from the client side.

Sending back a response is just as same as regular response handling.
* * * 
##Examples
Two KinomaJS sample applications are available on [GitHub](https://github.com/Kinoma/KPR-examples). These server and client share color information over Wi-Fi. The server is the central of the color information; clients get color information from the server and send new color to the server. Let’s start taking a look from server example because the main feature is on server.

[CoAP Server example](https://github.com/Kinoma/KPR-examples/tree/master/coap-server)

![](http://www.kinoma.com/develop/documentation/technotes/images/coap-client-and-server-in-kinomaJS/coap-server-example.jpg)


The Server example contains three files:

*	main.xml
*	server.js
* 	slider.xml

**main.xml** is the user interface and main application logic. **slider.xml** is the module for the Slider UI. **server.js** contains all CoAP server related code, which is imported into main.xml as a module named **SERVER**.

[CoAP Client example](https://github.com/Kinoma/KPR-examples/tree/master/coap-client)

![](http://www.kinoma.com/develop/documentation/technotes/images/coap-client-and-server-in-kinomaJS/coap-client-example.jpg)

Client has three tabs at the bottom.

*	Color Palette
*	RGB Slider
*	RGB Color Sensor

All user interface is defined in **main.xml**. The code for communication with server is stored in **client.js** and is imported into main.xml as a module named **CLIENT**.
* * * 
##Resources
*	[CoAP Constraint Application Protocol](https://tools.ietf.org/html/rfc7252)
*	[CoAP Response codes](https://tools.ietf.org/html/rfc7252#section-5.9)